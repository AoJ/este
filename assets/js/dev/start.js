// Generated by CoffeeScript 1.3.3
/**
  @fileoverview https://github.com/Steida/este.

  Features
    compile and watch CoffeeScript, Stylus, Soy, project-template.html
    update Google Closure deps.js
    run and watch *_test.coffee unit tests
    run simple NodeJS development server

  Options
    --debug     - shows time durations
    --deploy    - compile project-template.html with one script

  todo
    consider: delete .css and .js files on start
    group soy templates compilation into one task
*/

var Commands, addSoyTemplatesCompileCommands, booting, buildAndWatchProjectTemplate, clearScreen, debug, deploy, depsNamespaces, exec, fs, getPaths, getSoyCommand, http, jsSubdirs, onPathChange, pathModule, project, runCommands, runCommandsAsyncTimer, runServer, start, startTime, tests, watchOptions, watchPaths,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

fs = require('fs');

exec = require('child_process').exec;

tests = require('./tests');

http = require('http');

pathModule = require('path');

project = process.argv[2];

debug = __indexOf.call(process.argv, '--debug') >= 0;

deploy = __indexOf.call(process.argv, '--deploy') >= 0;

startTime = Date.now();

booting = true;

watchOptions = {
  interval: 10
};

jsSubdirs = (function() {
  var path, _i, _len, _ref, _results;
  _ref = fs.readdirSync('assets/js');
  _results = [];
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    path = _ref[_i];
    if (!fs.statSync("assets/js/" + path).isDirectory()) {
      continue;
    }
    _results.push(path);
  }
  return _results;
})();

depsNamespaces = (function() {
  var dir, namespaces;
  namespaces = (function() {
    var _i, _len, _results;
    _results = [];
    for (_i = 0, _len = jsSubdirs.length; _i < _len; _i++) {
      dir = jsSubdirs[_i];
      _results.push("--root_with_prefix=\"assets/js/" + dir + " ../../../" + dir + "\" ");
    }
    return _results;
  })();
  return namespaces.join('');
})();

Commands = {
  coffeeScripts: "coffee --compile --bare --output assets/js assets/js",
  closureDeps: "python assets/js/google-closure/closure/bin/build/depswriter.py    " + depsNamespaces + "    > assets/js/deps.js",
  mochaTests: tests.run,
  stylusStyles: function(callback) {
    var command, paths;
    paths = getPaths('assets', ['.styl']);
    command = "stylus --compress " + (paths.join(' '));
    return exec(command, callback);
  }
};

start = function() {
  runServer();
  buildAndWatchProjectTemplate();
  addSoyTemplatesCompileCommands();
  runCommands(Commands, function(success, commandName, command) {
    if (success) {
      console.log("Everything's fine, happy coding!", "" + ((Date.now() - startTime) / 1000) + "ms");
      booting = false;
      watchPaths(onPathChange);
      return;
    }
    return console.log("Error: " + commandName + " -> " + command);
  });
};

runServer = function() {
  var server;
  server = http.createServer(function(request, response) {
    var contentType, extname, filePath;
    filePath = '.' + request.url;
    if (filePath === './') {
      filePath = "./" + project + ".htm";
    }
    if (filePath.indexOf('?') !== -1) {
      filePath = filePath.split('?')[0];
    }
    extname = pathModule.extname(filePath);
    contentType = 'text/html';
    switch (extname) {
      case '.js':
        contentType = 'text/javascript';
        break;
      case '.css':
        contentType = 'text/css';
        break;
      case '.png':
        contentType = 'image/png';
        break;
      case '.gif':
        contentType = 'image/gif';
    }
    fs.exists(filePath, function(exists) {
      if (!exists) {
        filePath = "./" + project + ".html";
      }
      return fs.readFile(filePath, function(error, content) {
        if (error) {
          response.writeHead(500);
          response.end('500', 'utf-8');
          return;
        }
        response.writeHead(200, {
          'Content-Type': contentType
        });
        return response.end(content, 'utf-8');
      });
    });
  });
  server.listen(8000);
  return console.log('Server is listening at http://localhost:8000/');
};

buildAndWatchProjectTemplate = function() {
  var build;
  build = function() {
    var command;
    command = "node assets/js/dev/build " + project + " --onlyhtml";
    if (deploy) {
      command += ' --deploy';
    }
    exec(command);
    return console.log("" + project + "-template.html compiled.");
  };
  build();
  return fs.watchFile("" + project + "-template.html", watchOptions, function(curr, prev) {
    if (curr.mtime <= prev.mtime) {
      return;
    }
    return build();
  });
};

addSoyTemplatesCompileCommands = function() {
  var i, soyPath, soyPaths, _i, _len, _results;
  soyPaths = getPaths('assets', ['.soy']);
  _results = [];
  for (i = _i = 0, _len = soyPaths.length; _i < _len; i = ++_i) {
    soyPath = soyPaths[i];
    _results.push(Commands['soyTemplate ' + i] = getSoyCommand(soyPath));
  }
  return _results;
};

getPaths = function(directory, extensions, includeDirs) {
  var file, files, path, paths, _i, _len, _ref;
  paths = [];
  files = fs.readdirSync(directory);
  for (_i = 0, _len = files.length; _i < _len; _i++) {
    file = files[_i];
    path = directory + '/' + file;
    if (path.indexOf('/google-closure') > -1) {
      continue;
    }
    if (path.indexOf('/node_modules') > -1) {
      continue;
    }
    if (fs.statSync(path).isDirectory()) {
      if (includeDirs) {
        paths.push(path);
      }
      paths.push.apply(paths, getPaths(path, extensions, includeDirs));
    } else {
      if (_ref = pathModule.extname(path), __indexOf.call(extensions, _ref) >= 0) {
        paths.push(path);
      }
    }
  }
  return paths;
};

getSoyCommand = function(path) {
  return "java -jar assets/js/dev/SoyToJsSrcCompiler.jar    --shouldProvideRequireSoyNamespaces    --shouldGenerateJsdoc    --codeStyle concat    --outputPathFormat {INPUT_DIRECTORY}/{INPUT_FILE_NAME_NO_EXT}.js    " + path;
};

watchPaths = function(callback) {
  var path, paths, _fn, _i, _len;
  paths = getPaths('assets', ['.coffee', '.styl', '.soy'], true);
  _fn = function(path) {
    if (path.indexOf('.') > -1) {
      return fs.watchFile(path, watchOptions, function(curr, prev) {
        if (curr.mtime > prev.mtime) {
          return callback(path, false);
        }
      });
    } else {
      return fs.watch(path, watchOptions, function() {
        return callback(path, true);
      });
    }
  };
  for (_i = 0, _len = paths.length; _i < _len; _i++) {
    path = paths[_i];
    if (watchPaths['$' + path]) {
      continue;
    }
    watchPaths['$' + path] = true;
    _fn(path);
  }
};

onPathChange = function(path, dir) {
  var commands;
  if (dir) {
    watchPaths(onPathChange);
    return;
  }
  commands = {};
  switch (pathModule.extname(path)) {
    case '.coffee':
      commands["coffeeScript: " + path] = "coffee --compile --bare " + path;
      commands["mochaTests"] = Commands.mochaTests;
      commands["closureDeps"] = Commands.closureDeps;
      break;
    case '.styl':
      commands["stylusStyle: " + path] = "stylus --compress " + path;
      break;
    case '.soy':
      commands["soyTemplate: " + path] = getSoyCommand(path);
      break;
    default:
      return;
  }
  clearScreen();
  return runCommands(commands);
};

clearScreen = function() {
  process.stdout.write('\033[2J');
  return process.stdout.write('\033[1;3H');
};

runCommandsAsyncTimer = null;

runCommands = function(commands, onComplete) {
  var command, commandStartTime, k, name, nextCommands, onExec, v;
  for (name in commands) {
    command = commands[name];
    break;
  }
  if (!command) {
    if (onComplete) {
      onComplete(true);
    }
    return;
  }
  commandStartTime = Date.now();
  nextCommands = {};
  for (k in commands) {
    v = commands[k];
    if (k !== name) {
      nextCommands[k] = v;
    }
  }
  onExec = function(err, stdout, stderr) {
    if (err) {
      console.log(stderr);
      if (onComplete) {
        onComplete(false, name, command);
      }
      return;
    }
    if (booting || debug) {
      console.log(name, "" + ((Date.now() - commandStartTime) / 1000) + "ms");
    }
    return runCommands(nextCommands, onComplete);
  };
  if (typeof command === 'function') {
    command(onExec);
  } else {
    exec(command, onExec);
  }
};

start();
